-- StarterCharacterScripts/FirstPersonControllerWithRagdollHandoff (hardened)
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- wait for character and humanoid
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- server creates this event
local ragdollEvent = ReplicatedStorage:WaitForChild("RagdollCamEvent")

-- settings
local bobSpeed = .2
local bobDistance = .2
local bobWalkMulti = 55
local walkVeloThreshold = 9

local defaultFOV = 60
local targetFOV = 60
local fovChange = 8
local maxFOVvelocity = 10
local FOVsmooth = 3

local sensitivity = .15
local unlockMouseButton = Enum.KeyCode.G
local maxVerticalAngle = math.rad(80)
local camOffset = 2
local turnLeanAmt = 400
local turnLeanSmoothing = .9
local turnLeanMax = .2

local camSmooth = 16

-- controller state
local firstPersonEnabled = true
local verticalAngle, horizontalAngle, zAngle = 0, 0, 0
local targetCFrame = CFrame.new()
local targetRot    = CFrame.Angles(0,0,0)

-- originals
local originals = { mouseBehavior=nil, mouseIcon=nil, camMin=nil, camMax=nil, camMode=nil }

local function saveOriginals()
	originals.mouseBehavior = UserInputService.MouseBehavior
	originals.mouseIcon     = UserInputService.MouseIconEnabled
	originals.camMin        = player.CameraMinZoomDistance
	originals.camMax        = player.CameraMaxZoomDistance
	originals.camMode       = player.CameraMode
end

-- visibility helpers
local function showForThirdPerson(char)
	for _, d in ipairs(char:GetDescendants()) do
		if d:IsA("BasePart") then
			if d.Name ~= "HumanoidRootPart" then
				d.LocalTransparencyModifier = 0
			end
		elseif d:IsA("Decal") then
			d.Transparency = 0
		end
	end
end

local function hideForFirstPerson(char)
	for _, d in ipairs(char:GetDescendants()) do
		if d:IsA("BasePart") then
			d.LocalTransparencyModifier = 1
		elseif d:IsA("Decal") then
			d.Transparency = 1
		elseif d:IsA("Accessory") then
			local handle = d:FindFirstChildWhichIsA("BasePart")
			if handle then
				handle.LocalTransparencyModifier = 1
			end
		end
	end
	-- auto hide anything that spawns later like accessories replicated after join
	char.DescendantAdded:Connect(function(d)
		if d:IsA("BasePart") then
			d.LocalTransparencyModifier = 1
		elseif d:IsA("Decal") then
			d.Transparency = 1
		end
	end)
end

-- mouse lock
local function lockMouse()
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	UserInputService.MouseIconEnabled = false
end

-- adopt new CurrentCamera any time Roblox swaps it
local function adoptCurrentCamera()
	camera = Workspace.CurrentCamera
	if firstPersonEnabled then
		camera.CameraType = Enum.CameraType.Scriptable
		camera.CameraSubject = nil
		camera.FieldOfView = targetFOV
		camera.CFrame = targetCFrame
	end
end
Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(adoptCurrentCamera)

-- prepare rig and camera
local function waitRigAndPrime(char: Model)
	local hum = char:WaitForChild("Humanoid")
	local hrp = char:WaitForChild("HumanoidRootPart")
	if char.PrimaryPart ~= hrp then
		char.PrimaryPart = hrp
	end

	camera.CameraSubject = nil
	hum.CameraOffset = Vector3.new(0, 0, 0)

	verticalAngle, horizontalAngle, zAngle = 0, 0, 0
	targetRot = CFrame.Angles(0, 0, 0)

	local offset = Vector3.new(0, camOffset, 0)
	local startPos = hrp.Position + offset
	targetCFrame = CFrame.new(startPos) * targetRot
	camera.CFrame = targetCFrame
end

-- enter first person
local function enterFirstPerson()
	firstPersonEnabled = true
	camera.CameraType = Enum.CameraType.Scriptable
	camera.CameraSubject = nil
	lockMouse()
	humanoid.AutoRotate = false
end

-- one time initial
local function enterFirstPersonOnce()
	enterFirstPerson()
	task.defer(lockMouse)
	RunService.RenderStepped:Wait()
	lockMouse()
	UserInputService.WindowFocused:Connect(lockMouse)
	UserInputService.WindowFocusReleased:Connect(function()
		-- when alt tabbing, Roblox can flip MouseBehavior
		if firstPersonEnabled then
			task.wait() -- let OS focus settle
			lockMouse()
		end
	end)
end

-- camera math
local function UpdateCameraRotation(change)
	local c = change * sensitivity
	horizontalAngle += math.rad(c.x)
	zAngle = math.clamp(zAngle + (c.x / turnLeanAmt), -turnLeanMax, turnLeanMax)
	verticalAngle = math.clamp(verticalAngle + math.rad(c.y), -maxVerticalAngle, maxVerticalAngle)
	targetRot = CFrame.Angles(0, horizontalAngle, 0) * CFrame.Angles(verticalAngle, 0, 0)
end

local function UpdateCameraPosition()
	if not character then return end
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local bobPos = math.sin(tick() * bobSpeed) * bobDistance
	if hrp.AssemblyLinearVelocity.Magnitude >= walkVeloThreshold then
		bobPos = math.sin(tick() * (bobSpeed * bobWalkMulti)) * bobDistance
	end

	local offset = Vector3.new(0, camOffset + bobPos, 0)
	local pos = hrp.Position + offset
	targetCFrame = CFrame.new(pos) * targetRot
end

local function SmoothCameraZAxis(deltaTime)
	local amt = deltaTime / turnLeanSmoothing
	if zAngle > 0 then
		zAngle = math.max(zAngle - amt, 0)
	elseif zAngle < 0 then
		zAngle = math.min(zAngle + amt, 0)
	end
	local zRotation = CFrame.Angles(0, 0, zAngle)
	targetRot = CFrame.Angles(0, horizontalAngle, 0) * CFrame.Angles(verticalAngle, 0, 0) * zRotation
end

local function UpdateFOV(deltaTime)
	if not player.Character then return end
	local hrp = player.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	local velocity = hrp.AssemblyLinearVelocity.Magnitude
	local normalizedVelocity = math.clamp(velocity / maxFOVvelocity, 0, 1)
	targetFOV = defaultFOV + (normalizedVelocity * fovChange)
	camera.FieldOfView = camera.FieldOfView + (targetFOV - camera.FieldOfView) * deltaTime * FOVsmooth
end

-- inputs
UserInputService.InputChanged:Connect(function(input, processed)
	if not firstPersonEnabled then return end
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		UpdateCameraRotation(-Vector3.new(input.Delta.X, input.Delta.Y, 0))
	end
end)

UserInputService.InputBegan:Connect(function(input, processed)
	if processed or not firstPersonEnabled then return end
	if input.KeyCode == unlockMouseButton then
		if UserInputService.MouseIconEnabled then
			lockMouse()
		else
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			UserInputService.MouseIconEnabled = true
		end
	end
end)

UserInputService.TouchMoved:Connect(function(touch, processed)
	if processed or not firstPersonEnabled then return end
	UpdateCameraRotation(-Vector3.new(touch.Delta.X, touch.Delta.Y, 0))
end)

-- guard and update at camera priority
local function StepCamera(deltaTime)
	if firstPersonEnabled then
		-- guardrails: if anything changed the camera, take it back now
		if camera ~= Workspace.CurrentCamera then
			adoptCurrentCamera()
		end
		if camera.CameraType ~= Enum.CameraType.Scriptable then
			camera.CameraType = Enum.CameraType.Scriptable
		end
		if camera.CameraSubject ~= nil then
			camera.CameraSubject = nil
		end

		local dX, dY = UserInputService:GetMouseDelta()
		if dX ~= 0 or dY ~= 0 then
			UpdateCameraRotation(-Vector3.new(dX, dY, 0))
		end
		UpdateCameraPosition()
		SmoothCameraZAxis(deltaTime)
		UpdateFOV(deltaTime)
		camera.CFrame = camera.CFrame:Lerp(targetCFrame, deltaTime * camSmooth)

		-- optional face camera yaw without moving position
		if character and character.PrimaryPart then
			local _, camY, _ = camera.CFrame:ToOrientation()
			-- rotate locally by pivot, server will reconcile without big jumps
			character:PivotTo(CFrame.new(character.PrimaryPart.Position) * CFrame.Angles(0, camY, 0))
		end
	end
end

RunService:BindToRenderStep("FP_Camera", Enum.RenderPriority.Camera.Value, StepCamera)

-- initial first person
hideForFirstPerson(character)
waitRigAndPrime(character)
enterFirstPersonOnce()

-- respawn support that never disables the script
player.CharacterAdded:Connect(function(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	camera = Workspace.CurrentCamera
	hideForFirstPerson(character)
	waitRigAndPrime(character)
	enterFirstPerson()
end)

-- third person ragdoll handoff, then return to FP
local function enterRagdollThirdPerson(duration)
	duration = duration or 2
	firstPersonEnabled = false
	saveOriginals()

	showForThirdPerson(character)
	if humanoid then humanoid:UnequipTools() end

	player.CameraMode = Enum.CameraMode.Classic
	player.CameraMinZoomDistance = 8
	player.CameraMaxZoomDistance = 18

	camera.CameraType = Enum.CameraType.Scriptable
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if hrp then
		local back, up = 12, 7
		local pos = (hrp.CFrame * CFrame.new(0, up, back)).Position
		camera.CFrame = CFrame.lookAt(pos, hrp.Position + Vector3.new(0, 3, 0))
	end

	task.defer(function()
		camera.CameraType = Enum.CameraType.Custom
		camera.CameraSubject = humanoid
	end)

	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	UserInputService.MouseIconEnabled = true

	task.delay(duration, function()
		if not character or not character.Parent then return end
		hideForFirstPerson(character)

		player.CameraMinZoomDistance = originals.camMin or 0.5
		player.CameraMaxZoomDistance = originals.camMax or 128
		player.CameraMode = originals.camMode or Enum.CameraMode.Classic

		firstPersonEnabled = true
		camera = Workspace.CurrentCamera
		camera.CameraType = Enum.CameraType.Scriptable
		camera.CameraSubject = nil
		lockMouse()
		waitRigAndPrime(character)
	end)
end

ragdollEvent.OnClientEvent:Connect(function(duration)
	enterRagdollThirdPerson(duration)
end)

-- do not disable the script on death, just stop FP until next character
humanoid.Died:Connect(function()
	firstPersonEnabled = false
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	UserInputService.MouseIconEnabled = true
	-- let CoreScripts drive camera while dead
	camera = Workspace.CurrentCamera
	camera.CameraType = Enum.CameraType.Custom
	camera.CameraSubject = humanoid
end)
