-- ServerScriptService/PlankPlacement.server.lua
-- Requires player to HOLD the Plank tool to place.
-- If not holding Plank, the prompt briefly tells them to equip it.
-- Finds "Placeholders" anywhere under workspace.AOI and binds to existing + future slots.

local RS  = game:GetService("ReplicatedStorage")
local WK  = workspace

-- Config
local PLACE_MAX_DIST = 40
local RENAME_HOST_TO = "PlankPlaceholder"

-- Helpers
local function anyBasePart(inst)
	if inst:IsA("BasePart") then return inst end
	if inst:IsA("Model") then
		if inst.PrimaryPart then return inst.PrimaryPart end
		for _, d in ipairs(inst:GetDescendants()) do
			if d:IsA("BasePart") then return d end
		end
	end
	return nil
end

local function snapCF(slotBase)
	local a = slotBase:FindFirstChild("Snap")
	if a and a:IsA("Attachment") then
		return a.WorldCFrame
	end
	return slotBase.CFrame
end

local function isPlankTool(t)
	return t and t:IsA("Tool") and (t.Name == "Plank" or t:GetAttribute("IsPlankTool") == true)
end

local function getEquippedPlank(plr)
	local char = plr.Character
	if not char then return nil end
	for _, c in ipairs(char:GetChildren()) do
		if isPlankTool(c) then return c end
	end
	return nil
end

local function findPlankToolAnywhere(plr)
	local char = plr.Character
	if char then
		for _, c in ipairs(char:GetChildren()) do
			if isPlankTool(c) then return c end
		end
	end
	local bp = plr:FindFirstChildOfClass("Backpack")
	if bp then
		for _, c in ipairs(bp:GetChildren()) do
			if isPlankTool(c) then return c end
		end
	end
	return nil
end

local function flashPrompt(pp, actionText, objectText, seconds)
	local oldA, oldO = pp.ActionText, pp.ObjectText
	pp.ActionText, pp.ObjectText = actionText, objectText
	task.delay(seconds or 1.25, function()
		if pp and pp.Parent then
			pp.ActionText, pp.ObjectText = oldA, oldO
		end
	end)
end

-- Binding & seeding
local nextSlotId = 0

local function bindPlaceHandler(pp, host, bridgeRoot)
	if pp:GetAttribute("PlaceHandlerBound") then return end
	pp:SetAttribute("PlaceHandlerBound", true)

	if not host:GetAttribute("SlotId") then
		nextSlotId += 1
		host:SetAttribute("SlotId", nextSlotId)
	end

	pp.ActionText = "Place"
	pp.ObjectText = "Bridge Slot"
	pp.KeyboardKeyCode = Enum.KeyCode.E
	pp.GamepadKeyCode  = Enum.KeyCode.ButtonA
	pp.ClickablePrompt = true
	pp.HoldDuration = 0.5
	pp.RequiresLineOfSight = false
	pp.MaxActivationDistance = PLACE_MAX_DIST

	pp.Triggered:Connect(function(plr)
		-- Must currently be holding the Plank
		local equippedPlank = getEquippedPlank(plr)
		if not equippedPlank then
			flashPrompt(pp, "Equip Plank", "Hold Plank to place", 1.5)
			return
		end

		-- Occupancy
		local occ = host:FindFirstChild("Occupied")
		if occ and occ.Value == true then
			flashPrompt(pp, "Occupied", "Try another slot", 1.25)
			return
		end

		-- Template
		local TEMPLATE = RS:FindFirstChild("PlankTemplate")
		if not TEMPLATE then
			flashPrompt(pp, "Unavailable", "Plank asset missing", 1.25)
			return
		end

		-- Place at snap
		local targetCF = snapCF(host)
		local placed = TEMPLATE:Clone()
		local parentOK = bridgeRoot or WK

		if placed:IsA("BasePart") then
			placed.CFrame = targetCF
			placed.Anchored, placed.CanCollide, placed.Parent = true, true, parentOK
		else
			if not placed.PrimaryPart then
				for _, d in ipairs(placed:GetDescendants()) do
					if d:IsA("BasePart") then placed.PrimaryPart = d; break end
				end
			end
			if not placed.PrimaryPart then
				placed:Destroy()
				flashPrompt(pp, "Error", "Plank asset invalid", 1.25)
				return
			end
			placed:PivotTo(targetCF)
			placed.Parent = parentOK
		end

		-- Consume ONE plank tool (Character preferred; fallback to Backpack)
		local consumed = false
		if equippedPlank.Parent and equippedPlank.Parent:IsDescendantOf(plr.Character) then
			equippedPlank:Destroy()
			consumed = true
		else
			local anyPlank = findPlankToolAnywhere(plr)
			if anyPlank then
				anyPlank:Destroy()
				consumed = true
			end
		end

		if not consumed then
			placed:Destroy()
			flashPrompt(pp, "Equip Plank", "Hold Plank to place", 1.5)
			return
		end

		if occ then occ.Value = true end
		host:Destroy()
	end)
end

local function ensurePlacePromptOn(host, bridgeRoot)
	host.Name = RENAME_HOST_TO
	host.Anchored, host.CanCollide, host.Transparency = true, false, 1

	if not host:FindFirstChild("Occupied") then
		local b = Instance.new("BoolValue"); b.Name = "Occupied"; b.Value = false; b.Parent = host
	end
	if not host:FindFirstChild("Snap") then
		local a = Instance.new("Attachment"); a.Name = "Snap"; a.Parent = host
	end

	local pp = host:FindFirstChildOfClass("ProximityPrompt")
	if not pp then
		pp = Instance.new("ProximityPrompt")
		pp.Name = "PlacePlankHere"
		pp.Parent = host
	end

	bindPlaceHandler(pp, host, bridgeRoot)
end

local function seedUnder(placeholdersFolder)
	local bridgeRoot = placeholdersFolder.Parent
	for _, node in ipairs(placeholdersFolder:GetDescendants()) do
		local host = anyBasePart(node)
		if not host then
			for _, d in ipairs(node:GetDescendants()) do
				if d:IsA("BasePart") then host = d; break end
			end
		end
		if host then ensurePlacePromptOn(host, bridgeRoot) end
	end

	placeholdersFolder.DescendantAdded:Connect(function(d)
		task.defer(function()
			local host = anyBasePart(d) or (d:IsA("BasePart") and d) or nil
			if not host then
				for _, x in ipairs(d:GetDescendants()) do
					if x:IsA("BasePart") then host = x; break end
				end
			end
			if host then ensurePlacePromptOn(host, bridgeRoot) end
		end)
	end)
end

-- Flexible path: find "Placeholders" anywhere under workspace.AOI
local function findPlaceholdersUnderAOI()
	local AOI = WK:FindFirstChild("AOI")
	if not AOI then return nil end
	for _, d in ipairs(AOI:GetDescendants()) do
		if d.Name == "Placeholders" then return d end
	end
	return nil
end

local function tryWire()
	local placeholders = findPlaceholdersUnderAOI()
	if placeholders then
		seedUnder(placeholders)
		return true
	end
	return false
end

-- Kick off + retries for streamed/late creation
if not tryWire() then
	WK.DescendantAdded:Connect(function(d)
		if d.Name == "Placeholders" or d.Name == "AOI" or d.Name == "Bridge" then
			task.defer(tryWire)
		end
	end)
	for i = 1, 30 do task.delay(0.5 * i, tryWire) end
end
