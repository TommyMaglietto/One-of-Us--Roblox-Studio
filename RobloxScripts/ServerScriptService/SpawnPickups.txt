-- ServerScriptService/SpawnPickupsOnStumps.server.lua
-- Keys: exactly 5 random stumps get a Key
-- Non-key roll per stump: 9Volt 40 percent, Bandages 33 percent, Ammo 10 percent, None 17 percent
-- This version surface-locks items so they sit perfectly on top of each stump using a downward raycast

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local STUMPS_FOLDER = Workspace:WaitForChild("Stumps")
local PICKUPS_SOURCE = ReplicatedStorage:WaitForChild("PickUps")

local DEST_FOLDER = Workspace:FindFirstChild("SpawnedPickUps") or Instance.new("Folder")
DEST_FOLDER.Name = "SpawnedPickUps"
DEST_FOLDER.Parent = Workspace

-- RNG variety per server
do
	math.randomseed(tick() % 1e6)
	for _ = 1, 5 do math.random() end
end

-- Non-key outcomes for the other stumps must cover 1..100
local NON_KEY_RANGES = {
	{ name = "9Volt",    low = 1,   high = 40 },  -- 40 percent
	{ name = "Bandages", low = 41,  high = 73 },  -- 33 percent
	{ name = "Ammo",     low = 74,  high = 83 },  -- 10 percent
	{ name = "None",     low = 84,  high = 100 }, -- 17 percent
}

-- Per-item local offsets and rotations applied after centering
-- Positive Y raises, negative Y lowers
local ITEM_OFFSETS = {
	Ammo      = Vector3.new(0, 0, 0), -- keep as requested; set to Vector3.new() if you want exact flush
	Bandages  = Vector3.new(0, 0, 0),
	["9Volt"] = Vector3.new(0, .38, 0),
	Key       = Vector3.new(0, 0, 0),
}

-- Optional extra rotation for specific items (degrees)
local ITEM_ROTATIONS = {
	Bandages = Vector3.new(0, 0, 0), -- set e.g. Vector3.new(0, 90, 0) if you want a 90 degree yaw
}

-- Placement tuning
local CLEARANCE_Y     = 0.0      -- zero so items rest exactly on the top surface
local MAX_LIFT_TRIES  = 5        -- small safety lift only if intersecting non-stump parts
local LIFT_STEP       = 0.02
local ADD_RANDOM_YAW  = true
local STUMP_MARKER_NAME = "PlaceHere"

-- Overlap checks should ignore the clone, the chosen stump, and terrain
local function makeOverlapParams(ignoreList)
	local p = OverlapParams.new()
	p.FilterType = Enum.RaycastFilterType.Exclude
	p.FilterDescendantsInstances = ignoreList
	return p
end

---------------------------------------------------------------------
-- Helpers
---------------------------------------------------------------------

local function getAnyBasePart(instance)
	if instance:IsA("BasePart") then return instance end
	for _, d in ipairs(instance:GetDescendants()) do
		if d:IsA("BasePart") then return d end
	end
	return nil
end

local function ensurePrimaryPart(model)
	if not model or not model:IsA("Model") then return nil end
	if model.PrimaryPart and model.PrimaryPart.Parent == model then
		return model.PrimaryPart
	end
	local part = getAnyBasePart(model)
	if part then
		model.PrimaryPart = part
		return part
	end
	return nil
end

-- Highest top surface among parts in the stump
local function getStumpTopPart(stump)
	if stump:IsA("BasePart") then return stump end
	local topPart, topY = nil, -math.huge
	for _, p in ipairs(stump:GetDescendants()) do
		if p:IsA("BasePart") then
			local thisTop = p.Position.Y + p.Size.Y * 0.5
			if thisTop > topY then
				topY = thisTop
				topPart = p
			end
		end
	end
	return topPart
end

-- Optional precision centering via Attachment named PlaceHere anywhere under stump
local function findStumpMarker(stump)
	if stump:IsA("Attachment") and stump.Name == STUMP_MARKER_NAME then
		return stump
	end
	if stump:IsA("BasePart") or stump:IsA("Model") then
		return stump:FindFirstChild(STUMP_MARKER_NAME, true)
	end
	return nil
end

-- Raycast straight down at XZ to find the true top surface Y of this stump
local function raycastTopY(stump, x, z)
	local topPart = getStumpTopPart(stump)
	local startY = topPart and (topPart.Position.Y + topPart.Size.Y + 10) or (Workspace.FallenPartsDestroyHeight + 1000)
	local origin = Vector3.new(x, startY, z)
	local direction = Vector3.new(0, -2000, 0)

	local rp = RaycastParams.new()
	rp.FilterType = Enum.RaycastFilterType.Include
	rp.FilterDescendantsInstances = { stump }

	local hit = Workspace:Raycast(origin, direction, rp)
	if hit then
		return hit.Position.Y
	end

	-- Fallback to simple top plane if raycast missed
	if topPart then
		return topPart.Position.Y + topPart.Size.Y * 0.5
	end

	-- Last resort
	return origin.Y - 10
end

local function anglesFromDegrees(degVec)
	return CFrame.Angles(math.rad(degVec.X), math.rad(degVec.Y), math.rad(degVec.Z))
end

-- Build a CFrame whose bottom sits exactly on the stump top at the chosen XZ
local function buildSurfaceLockedCF(stump, itemModel)
	local yawDegrees = ADD_RANDOM_YAW and math.random(0, 359) or 0
	local baseYaw = CFrame.Angles(0, math.rad(yawDegrees), 0)

	-- decide XZ center
	local marker = findStumpMarker(stump)
	local cx, cz
	if marker and marker:IsA("Attachment") then
		cx, cz = marker.WorldPosition.X, marker.WorldPosition.Z
	else
		local tp = getStumpTopPart(stump)
		if tp then
			cx, cz = tp.Position.X, tp.Position.Z
		else
			local stumpCF = stump:IsA("Model") and select(1, stump:GetBoundingBox()) or stump.CFrame
			cx, cz = stumpCF.Position.X, stumpCF.Position.Z
		end
	end

	-- rotate the item first to get correct world height
	local itemCFForSize = CFrame.new(0, 0, 0) * baseYaw
	local _, itemSize = itemModel:GetBoundingBox()
	-- yaw does not change Y size, but future per-item rotations might. Apply them here virtually:
	local extraRot = ITEM_ROTATIONS[itemModel.Name]
	if extraRot then
		itemCFForSize = itemCFForSize * anglesFromDegrees(extraRot)
	end
	-- We cannot query size after virtual rotation without moving the instance,
	-- but yaw keeps Y extent unchanged. Extra rotations are small; we will still surface-lock via raycast Y.

	local topY = raycastTopY(stump, cx, cz)
	local targetY = topY + (itemSize.Y * 0.5) + CLEARANCE_Y

	local cf = CFrame.new(Vector3.new(cx, targetY, cz)) * baseYaw
	-- apply per-item rotation and offset
	if extraRot then
		cf = cf * anglesFromDegrees(extraRot)
	end
	local off = ITEM_OFFSETS[itemModel.Name]
	if off then
		cf = cf * CFrame.new(off)
	end
	return cf
end

-- Check overlap at a proposed placement
local function isOverlappingAtCF(targetCF, itemModel, ignoreList)
	local _, size = itemModel:GetBoundingBox()
	local hits = Workspace:GetPartBoundsInBox(targetCF, size, makeOverlapParams(ignoreList))
	return (#hits > 0)
end

-- Small safety lift only if intersecting with non-stump parts
local function safePivotTo(clone, baseCF, stump)
	local ignoreList = { clone, stump, Workspace.Terrain }

	local cf = baseCF
	for _ = 1, MAX_LIFT_TRIES do
		if not isOverlappingAtCF(cf, clone, ignoreList) then
			clone:PivotTo(cf)
			return true
		end
		cf = cf + Vector3.new(0, LIFT_STEP, 0)
	end
	clone:PivotTo(cf)
	warn(("Pickup %s placed but may still be intersecting after max lifts"):format(clone.Name))
	return false
end

-- Place a specific item on a stump with all rules
local function placePickupOnStump(itemName, stump)
	local src = PICKUPS_SOURCE:FindFirstChild(itemName)
	if not src then
		warn(("PickUp %s not found under ReplicatedStorage.PickUps"):format(itemName))
		return
	end

	local clone = src:Clone()
	clone.Parent = DEST_FOLDER

	if clone:IsA("Model") then ensurePrimaryPart(clone) end

	local targetCF = buildSurfaceLockedCF(stump, clone)
	safePivotTo(clone, targetCF, stump)
end

local function pickNonKeyOutcome()
	local roll = math.random(1, 100)
	for _, r in ipairs(NON_KEY_RANGES) do
		if roll >= r.low and roll <= r.high then
			return r.name
		end
	end
	return "None"
end

---------------------------------------------------------------------
-- Key selection and spawning flow
---------------------------------------------------------------------

local function shuffle(a)
	for i = #a, 2, -1 do
		local j = math.random(1, i)
		a[i], a[j] = a[j], a[i]
	end
	return a
end

local function chooseKeyStumps(allStumps, keysToPlace)
	local filtered = {}
	for _, s in ipairs(allStumps) do
		if s:IsA("Model") or s:IsA("BasePart") then
			table.insert(filtered, s)
		end
	end
	if #filtered == 0 then return {}, {} end
	shuffle(filtered)
	local nKeys = math.clamp(keysToPlace, 0, #filtered)
	local keyStumps, otherStumps = {}, {}
	for i, stump in ipairs(filtered) do
		if i <= nKeys then
			table.insert(keyStumps, stump)
		else
			table.insert(otherStumps, stump)
		end
	end
	return keyStumps, otherStumps
end

---------------------------------------------------------------------
-- Main
---------------------------------------------------------------------

local KEYS_TO_PLACE = 5
local placedKeys = 0

-- Snapshot current stumps
local initialStumps = STUMPS_FOLDER:GetChildren()
local keyStumps, otherStumps = chooseKeyStumps(initialStumps, KEYS_TO_PLACE)

-- Place Keys first
for _, stump in ipairs(keyStumps) do
	placePickupOnStump("Key", stump)
	placedKeys += 1
end

-- Then roll on the rest
for _, stump in ipairs(otherStumps) do
	local outcome = pickNonKeyOutcome()
	if outcome ~= "None" then
		placePickupOnStump(outcome, stump)
	end
end

-- Handle stumps added later
STUMPS_FOLDER.ChildAdded:Connect(function(child)
	task.wait(0.1)
	if placedKeys < KEYS_TO_PLACE then
		placePickupOnStump("Key", child)
		placedKeys += 1
		return
	end
	local outcome = pickNonKeyOutcome()
	if outcome ~= "None" then
		placePickupOnStump(outcome, child)
	end
end)
