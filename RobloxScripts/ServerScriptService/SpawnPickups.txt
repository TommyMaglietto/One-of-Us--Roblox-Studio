-- Spawns pickups on stumps only.
-- ReplicatedStorage/PickUps must contain Models named exactly: 9Volt, Ammo, Bandages, Key
-- Effects:
--   Key, Bandages -> add simple Tools to default toolbar (handleless)
--   9Volt         -> +20 to flashlight battery NumberValue (clamped 0..100)
--   Ammo          -> +3 to Ammo HUD via RemoteEvent
-- De-dup logic ensures at most ONE pickup per stump even if another spawner runs.

local RS        = game:GetService("ReplicatedStorage")
local Players   = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local Http      = game:GetService("HttpService")

-- ---------------- ICON HELPER ----------------
-- Looks for ReplicatedStorage/ToolIcons/<ToolName> and pulls an asset id from it.
-- Supports StringValue, IntValue, NumberValue, ImageLabel, ImageButton, Decal, Texture.
local ICONS = RS:FindFirstChild("ToolIcons")

local function normalizeAssetId(v)
	if v == nil or v == "" then return nil end
	if typeof(v) == "number" then return "rbxassetid://" .. v end
	if typeof(v) == "string" then
		if v:match("^%d+$") then return "rbxassetid://" .. v end
		return v
	end
	return nil
end

local function extractIconId(iconObj)
	if not iconObj then return nil end
	if iconObj:IsA("ImageLabel") or iconObj:IsA("ImageButton") then
		return normalizeAssetId(iconObj.Image)
	elseif iconObj:IsA("Decal") or iconObj:IsA("Texture") then
		return normalizeAssetId(iconObj.Texture)
	elseif iconObj:IsA("StringValue") then
		return normalizeAssetId(iconObj.Value)
	elseif iconObj:IsA("IntValue") or iconObj:IsA("NumberValue") then
		return normalizeAssetId(iconObj.Value)
	end
	return nil
end

local function getIconIdByName(toolName)
	if not ICONS then return nil end
	local obj = ICONS:FindFirstChild(toolName)
	-- simple fallback for Bandage vs Bandages naming
	if not obj and toolName == "Bandages" then obj = ICONS:FindFirstChild("Bandage") end
	if not obj and toolName == "Bandage"  then obj = ICONS:FindFirstChild("Bandages") end
	if not obj then return nil end
	return extractIconId(obj)
end

-- ---------------- LOGGING ----------------
local ENABLE_LOGS = true
local function LOG(...)  if ENABLE_LOGS then print("[Pickups]", ...) end end
local function WARN(...) warn("[Pickups]", ...) end

local SPAWNER_ID = Http:GenerateGUID(false)
LOG("Spawner starting. ID=", SPAWNER_ID)

-- ---------------- REMOTES ----------------
local Remotes = RS:FindFirstChild("Remotes") or Instance.new("Folder")
Remotes.Name = "Remotes"
Remotes.Parent = RS
local AddAmmoHUD = Remotes:FindFirstChild("AddAmmoHUD") or Instance.new("RemoteEvent")
AddAmmoHUD.Name = "AddAmmoHUD"
AddAmmoHUD.Parent = Remotes

-- ---------------- SOURCES ----------------
local STUMPS_FOLDER  = Workspace:WaitForChild("Stumps")
local PICKUPS_SOURCE = RS:WaitForChild("PickUps")

-- Distribution for non-key items
local NON_KEY_RANGES = {
	{ name = "9Volt",    low = 1,   high = 40 },
	{ name = "Bandages", low = 41,  high = 73 },
	{ name = "Ammo",     low = 74,  high = 83 },
	{ name = "None",     low = 84,  high = 100 },
}
local KEYS_TO_PLACE = 5
local ADD_RANDOM_YAW = true

local PICKUP_NAMES = { Key=true, Bandages=true, Ammo=true, ["9Volt"]=true }

-- ---------------- UTILS ----------------
do
	math.randomseed(tick() % 1e6)
	for _ = 1, 5 do math.random() end
end

local function getAnyBasePart(inst)
	if inst:IsA("BasePart") then return inst end
	for _, d in ipairs(inst:GetDescendants()) do
		if d:IsA("BasePart") then return d end
	end
end

local function topPartOfStump(stump)
	if stump:IsA("BasePart") then return stump end
	local top, topY = nil, -math.huge
	for _, p in ipairs(stump:GetDescendants()) do
		if p:IsA("BasePart") then
			local y = p.Position.Y + p.Size.Y * 0.5
			if y > topY then topY = y; top = p end
		end
	end
	return top
end

local function placeOnTop(stump, model)
	if model:IsA("Model") and not model.PrimaryPart then
		local pp = getAnyBasePart(model)
		if pp then model.PrimaryPart = pp end
	end
	local tp = topPartOfStump(stump)
	if not tp then return end
	local yaw = ADD_RANDOM_YAW and math.rad(math.random(0,359)) or 0
	local _, size = model:GetBoundingBox()
	local y = tp.Position.Y + tp.Size.Y * 0.5 + size.Y * 0.5
	local pos = Vector3.new(tp.Position.X, y, tp.Position.Z)
	model:PivotTo(CFrame.new(pos) * CFrame.Angles(0, yaw, 0))
end

local function pickNonKey()
	local r = math.random(1, 100)
	for _, w in ipairs(NON_KEY_RANGES) do
		if r >= w.low and r <= w.high then return w.name end
	end
	return "None"
end

local function shuffle(a)
	for i = #a, 2, -1 do
		local j = math.random(1, i)
		a[i], a[j] = a[j], a[i]
	end
end

local function chooseKeyStumps(allStumps, keysWanted)
	local a = {}
	for _, s in ipairs(allStumps) do
		if s:IsA("Model") or s:IsA("BasePart") then
			table.insert(a, s)
		end
	end
	shuffle(a)
	local keyStumps, others = {}, {}
	local nKeys = math.clamp(keysWanted, 0, #a)
	for i, s in ipairs(a) do
		if i <= nKeys then table.insert(keyStumps, s) else table.insert(others, s) end
	end
	return keyStumps, others
end

-- ---------------- DE-DUP MECHANICS ----------------
local function existingPickupsNearStump(stump)
	local tp = topPartOfStump(stump)
	if not tp then return {} end
	local center = CFrame.new(tp.Position + Vector3.new(0, tp.Size.Y * 0.5 + 2, 0))
	local extents = Vector3.new(6, 8, 6)

	local params = OverlapParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.FilterDescendantsInstances = { stump, Workspace.Terrain }

	local hits = Workspace:GetPartBoundsInBox(center, extents, params)
	local models, seen = {}, {}
	for _, part in ipairs(hits) do
		local m = part:FindFirstAncestorOfClass("Model")
		if m and not seen[m] and PICKUP_NAMES[m.Name] then
			seen[m] = true
			table.insert(models, m)
		end
	end
	return models
end

local function dedupeAfterSpawn(stump, keepName)
	local list = existingPickupsNearStump(stump)
	if #list <= 1 then return 0 end

	local keep = nil
	for _, m in ipairs(list) do
		if m:GetAttribute("SpawnedBy") == SPAWNER_ID and m.Name == keepName then
			keep = m; break
		end
	end
	keep = keep or list[1]

	local removed = 0
	for _, m in ipairs(list) do
		if m ~= keep then
			removed += 1
			LOG("De-dup removed extra pickup:", m.Name, "on stump", stump:GetFullName())
			m:Destroy()
		end
	end
	return removed
end

-- ---------------- PICKUP EFFECTS ----------------
local function waitBackpack(plr)
	local deadline = os.clock() + 3
	local bp = plr:FindFirstChildOfClass("Backpack")
	while not bp and os.clock() < deadline do
		task.wait()
		bp = plr:FindFirstChildOfClass("Backpack")
	end
	return bp
end

-- counts matching Tools in Backpack and Character
local function countTools(plr, toolName)
	local n = 0
	local function scan(container)
		if not container then return end
		for _, t in ipairs(container:GetChildren()) do
			if t:IsA("Tool") and t.Name == toolName then
				n += 1
			end
		end
	end
	scan(waitBackpack(plr))
	scan(plr.Character)
	return n
end

-- giveTool supports duplicates via maxCopies
-- set maxCopies = 1 for unique Tools like Key
-- set maxCopies = big number for stackable tools like Bandages
local function giveTool(plr, toolName, maxCopies)
	maxCopies = maxCopies or math.huge
	local bp = waitBackpack(plr)
	if not bp then
		WARN("No backpack for", plr.Name, "so", toolName, "not given")
		return false
	end

	local have = countTools(plr, toolName)
	if have >= maxCopies then
		LOG("Cap reached for", toolName, "have", have, "max", maxCopies, "->", plr.Name)
		return true
	end

	local t = Instance.new("Tool")
	t.Name = toolName
	t.RequiresHandle = false
	t.CanBeDropped = false

	-- set the icon before parenting so the default toolbar shows it immediately
	local id = getIconIdByName(toolName)
	if id then
		t.TextureId = id
	end

	t.Parent = bp
	LOG("Gave tool", toolName, "to", plr.Name, "(now", have + 1 .. ")")
	return true
end

local function findBatteryNumberValue(plr)
	local function scan(container)
		if not container then return nil end
		for _, t in ipairs(container:GetChildren()) do
			if t:IsA("Tool") and (t.Name == "FlashLight" or t.Name == "Flashlight") then
				local n = t:FindFirstChild("BatteryValue") or t:FindFirstChild("Battery") or t:FindFirstChild("BatteryPercent")
				if n and n:IsA("NumberValue") then return n end
			end
		end
	end
	local char = plr.Character
	return scan(char) or scan(plr:FindFirstChildOfClass("Backpack"))
end

local function applyPickupEffect(worldModel, itemName, plr)
	if itemName == "Key" then
		if giveTool(plr, "Key", 1) then
			worldModel:Destroy()
		end
	elseif itemName == "Bandages" then
		if giveTool(plr, "Bandages", 99) then
			worldModel:Destroy()
		end
	elseif itemName == "9Volt" then
		local batt = findBatteryNumberValue(plr)
		if batt then
			local before = batt.Value or 0
			batt.Value = math.clamp(before + 20, 0, 100)
			LOG("9Volt used by", plr.Name, "Battery:", before, "->", batt.Value)
			worldModel:Destroy()
		else
			LOG("9Volt not consumed (no Battery NumberValue found) for", plr.Name)
		end
	elseif itemName == "Ammo" then
		AddAmmoHUD:FireClient(plr, 3)
		LOG("Ammo +3 HUD for", plr.Name)
		worldModel:Destroy()
	end
end

local function createPrompt(host)
	local part = host:IsA("Model") and (host.PrimaryPart or host:FindFirstChildWhichIsA("BasePart", true)) or host
	if not part then return nil end
	local p = part:FindFirstChildOfClass("ProximityPrompt") or Instance.new("ProximityPrompt")
	p.Name = "PickupPrompt"
	p.ActionText = "Pick up"
	p.KeyboardKeyCode = Enum.KeyCode.E
	p.HoldDuration = 0.6
	p.RequiresLineOfSight = false
	p.MaxActivationDistance = 8
	p.Parent = part
	return p
end

-- ---------------- SPAWN PIPELINE ----------------
local function spawnOne(itemName, stump)
	local exist = existingPickupsNearStump(stump)
	if #exist > 0 then
		local names = {}
		for _, m in ipairs(exist) do table.insert(names, m.Name) end
		LOG("SKIP spawn on stump (already present):", table.concat(names, ","), " at ", stump:GetFullName())
		return
	end

	local src = PICKUPS_SOURCE:FindFirstChild(itemName)
	if not src then WARN("PickUps missing model:", itemName); return end

	local m = src:Clone()
	m.Name = itemName
	m:SetAttribute("SpawnedBy", SPAWNER_ID)
	m.Parent = Workspace

	placeOnTop(stump, m)
	LOG("Spawned", itemName, "on stump", stump:GetFullName())

	local removed = dedupeAfterSpawn(stump, itemName)
	if removed > 0 then
		LOG("Post-spawn de-dup removed", removed, "extras on stump", stump:GetFullName())
	end

	local prompt = createPrompt(m)
	if not prompt then WARN("No prompt host on spawned model", itemName); return end
	prompt.ObjectText = itemName
	prompt.Triggered:Connect(function(plr)
		if not prompt.Enabled then return end
		prompt.Enabled = false
		LOG("Pickup triggered:", itemName, "by", plr.Name)
		applyPickupEffect(m, itemName, plr)
		if m and m.Parent then
			prompt.Enabled = true
		end
	end)
end

-- ---------------- INITIAL & FUTURE STUMPS ----------------
local all = STUMPS_FOLDER:GetChildren()
local keyStumps, others = chooseKeyStumps(all, KEYS_TO_PLACE)
LOG("Initial stumps:", #all, "Keys target:", KEYS_TO_PLACE, "Chosen keys:", #keyStumps, "Others:", #others)

for _, s in ipairs(keyStumps) do spawnOne("Key", s) end
for _, s in ipairs(others) do
	local n = pickNonKey()
	if n ~= "None" then spawnOne(n, s) end
end

local placedKeys = #keyStumps
STUMPS_FOLDER.ChildAdded:Connect(function(stump)
	task.wait(0.1)
	if placedKeys < KEYS_TO_PLACE then
		LOG("New stump -> placing Key")
		spawnOne("Key", stump)
		placedKeys += 1
	else
		local n = pickNonKey()
		LOG("New stump -> placing", n)
		if n ~= "None" then spawnOne(n, stump) end
	end
end)
