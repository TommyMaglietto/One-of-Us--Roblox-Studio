-- StarterPlayerScripts/RoleClient.client.lua
local Players      = game:GetService("Players")
local RS           = game:GetService("ReplicatedStorage")
local RunService   = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer

local Remotes     = RS:WaitForChild("Remotes")
local RoundPhase  = Remotes:WaitForChild("RoundPhase")
local ClientReady = Remotes:WaitForChild("ClientReady")
local ClientAck   = Remotes:WaitForChild("ClientAck")

-- UI (existing)
local gui      = player:WaitForChild("PlayerGui"):WaitForChild("RoleRevealGui")
local card     = gui:WaitForChild("Card")
local rolling  = card:WaitForChild("RollingLabel")   -- flip animation only
local result   = card:WaitForChild("ResultLabel")    -- final role only
local bottom   = card:WaitForChild("BottomHint")
local sfx      = card:FindFirstChildWhichIsA("Sound")

-- Dedicated Waiting label so we never reuse 'result' for Ready text
local statusLabel = card:FindFirstChild("StatusLabel")
if not statusLabel then
	statusLabel = Instance.new("TextLabel")
	statusLabel.Name = "StatusLabel"
	statusLabel.BackgroundTransparency = 1
	statusLabel.Size = UDim2.new(1, 0, 0, 48)
	statusLabel.Position = UDim2.new(0, 0, 0.55, 0)
	statusLabel.Font = Enum.Font.GothamBold
	statusLabel.TextScaled = true
	statusLabel.TextColor3 = Color3.new(1,1,1)
	statusLabel.TextStrokeTransparency = 0.5
	statusLabel.ZIndex = 20
	statusLabel.Text = ""
	statusLabel.Visible = false
	statusLabel.Parent = card
end

-- Layer order
card.ZIndex = 10
rolling.ZIndex = 15
result.ZIndex = 16
bottom.ZIndex = 17
statusLabel.ZIndex = 18

-- Controls helper
local function setControlsEnabled(enabled)
	local playerModule = require(player:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"))
	local controls = playerModule:GetControls()
	if enabled then controls:Enable() else controls:Disable() end

	local char = player.Character or player.CharacterAdded:Wait()
	local hum  = char:WaitForChild("Humanoid")
	if enabled then
		player.CameraMode = Enum.CameraMode.Classic
		hum.WalkSpeed, hum.JumpPower = 16, 50
	else
		player.CameraMode = Enum.CameraMode.LockFirstPerson
		hum.WalkSpeed, hum.JumpPower = 0, 0
	end
end

-- Hard reset
local function hideAll()
	gui.Enabled = false
	card.Visible = false
	rolling.Visible = false
	result.Visible = false
	statusLabel.Visible = false
	rolling.Text = ""
	result.Text = ""
	statusLabel.Text = ""
	bottom.Text = ""
	card.BackgroundTransparency = 0 -- keep solid when visible
end

local function showWaiting()
	gui.Enabled = true
	card.Visible = true
	card.BackgroundTransparency = 0

	statusLabel.Visible = true
	statusLabel.Text = "Waiting For Players"

	rolling.Visible = false
	rolling.Text = ""
	result.Visible = false
	result.Text = ""

	bottom.Text = "Preparing..."
end

local function updateWaiting(payload)
	if not gui.Enabled or not statusLabel.Visible then
		showWaiting()
	end
	statusLabel.Text = string.format("Ready %d / %d", payload.ready or 0, payload.expected or 0)
	bottom.Text = string.format("Starting in %ds  Present %d", payload.secondsLeft or 0, payload.present or 0)
end

local function hideWaiting()
	statusLabel.Visible = false
	statusLabel.Text = ""
	bottom.Text = ""
	gui.Enabled = false
	card.Visible = false
end

-- Collect all GUI objects we can fade
local function collectFadeTargets(root)
	local list = {}
	for _, d in ipairs(root:GetDescendants()) do
		if d:IsA("GuiObject") then
			table.insert(list, d)
		end
	end
	return list
end

-- Fade the entire GUI (text, images, backgrounds, strokes) then hide & restore originals
local function fadeOutGuiThenHide(root, duration)
	duration = duration or 0.6
	local tweens = {}
	local originals = {}

	local function addTween(inst, prop, toValue)
		local fromValue = inst[prop]
		originals[#originals+1] = {inst = inst, prop = prop, value = fromValue}
		local tween = TweenService:Create(inst, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {[prop] = toValue})
		table.insert(tweens, tween)
		return tween
	end

	for _, g in ipairs(collectFadeTargets(root)) do
		-- Background
		if g:IsA("Frame") or g:IsA("TextLabel") or g:IsA("TextButton") or g:IsA("ImageLabel") or g:IsA("ImageButton") or g:IsA("ScrollingFrame") then
			if g.BackgroundTransparency < 1 then
				addTween(g, "BackgroundTransparency", 1)
			end
		end
		-- Images
		if (g:IsA("ImageLabel") or g:IsA("ImageButton")) and g.Image ~= "" then
			if g.ImageTransparency < 1 then
				addTween(g, "ImageTransparency", 1)
			end
		end
		-- Text
		if (g:IsA("TextLabel") or g:IsA("TextButton")) and g.Text ~= "" then
			if g.TextTransparency < 1 then
				addTween(g, "TextTransparency", 1)
			end
			if g.TextStrokeTransparency < 1 then
				addTween(g, "TextStrokeTransparency", 1)
			end
		end
		-- UIStroke (if present)
		local stroke = g:FindFirstChildOfClass("UIStroke")
		if stroke and stroke.Transparency < 1 then
			addTween(stroke, "Transparency", 1)
		end
	end

	for _, t in ipairs(tweens) do t:Play() end
	local elapsed = 0
	while elapsed < duration do
		local dt = RunService.Heartbeat:Wait()
		elapsed += dt
	end

	-- Hide and restore originals so next round starts pristine
	gui.Enabled = false
	card.Visible = false
	for _, rec in ipairs(originals) do
		if rec.inst and rec.inst.Parent then
			rec.inst[rec.prop] = rec.value
		end
	end
end

-- ==============================
-- Exponential ease-out flip: fast -> slow until reveal
-- ==============================
local FLIP_WORDS = {"Skinwalker","Human","Human","Skinwalker","Human"}
local function playFlipAnimation(duration)
	-- Tweakables
	local MIN_STEP = 0.03   -- fastest swap interval at the start
	local MAX_STEP = 0.22   -- slowest near the end

	-- Setup
	rolling.Visible = true
	result.Visible  = false
	statusLabel.Visible = false
	rolling.Text = "â€”"

	local start = os.clock()
	local lastSwap = start
	local idx = 1

	local function easeOutExpo(p)
		if p >= 1 then return 1 end
		return 1 - 2^(-10 * p)
	end

	while true do
		local t = os.clock() - start
		if t >= duration then break end

		local p = math.clamp(t / duration, 0, 1)
		local eased = easeOutExpo(p)
		local step = MIN_STEP + (MAX_STEP - MIN_STEP) * eased

		if os.clock() - lastSwap >= step then
			idx = (idx % #FLIP_WORDS) + 1
			rolling.Text = FLIP_WORDS[idx]
			lastSwap = os.clock()
		end

		RunService.Heartbeat:Wait()
	end
end

-- Phase handler
RoundPhase.OnClientEvent:Connect(function(msg)
	local phase = msg.phase
	local p     = msg.payload or {}

	if phase == "Waiting" then
		setControlsEnabled(false)
		hideAll()
		showWaiting()

	elseif phase == "WaitingUpdate" then
		updateWaiting(p)

	elseif phase == "WaitingEnd" then
		-- Kill waiting visuals before acknowledging
		hideWaiting()
		task.defer(function()
			pcall(function() ClientAck:FireServer({phase = "WaitingEnd"}) end)
		end)

	elseif phase == "RevealBegin" then
		-- Clean slate for reveal
		gui.Enabled = true
		card.Visible = true
		card.BackgroundTransparency = 0

		statusLabel.Visible = false
		statusLabel.Text = ""

		result.Visible = false
		result.Text = ""
		bottom.Text = "Determining your role..."
		playFlipAnimation(p.flip or 3.0)

	elseif phase == "RevealRole" then
		rolling.Visible = false
		rolling.Text = ""
		statusLabel.Visible = false
		statusLabel.Text = ""

		result.Visible  = true
		result.Text     = "You are a ...\n" .. tostring(p.role or "Human")

		if sfx and sfx.SoundId and sfx.SoundId ~= "" then
			pcall(function() sfx.TimePosition = 0; sfx:Play() end)
		end
		-- No fade here; we fade the whole GUI only when gameplay starts (Active)

	elseif phase == "Active" then
		-- Fade the entire GUI, then hide & unlock
		fadeOutGuiThenHide(gui, 0.6)
		setControlsEnabled(true)

	elseif phase == "RoundEnd" then
		-- If the round is force-ended during reveal/waiting, fade out as well
		fadeOutGuiThenHide(gui, 0.4)
		setControlsEnabled(true)
	end
end)

-- Tell server we're ready after spawn/UI mount
local function fireReadyOnce()
	task.defer(function()
		local character = player.Character or player.CharacterAdded:Wait()
		character:WaitForChild("Humanoid")
		task.wait(0.25)
		pcall(function() ClientReady:FireServer() end)
	end)
end

if player.Character then fireReadyOnce() end
player.CharacterAdded:Connect(fireReadyOnce)
