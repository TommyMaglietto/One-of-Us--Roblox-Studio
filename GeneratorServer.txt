-- ServerScriptService/GeneratorServer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local GenFolder   = ReplicatedStorage:WaitForChild("GenSystem")
local Remotes     = GenFolder:WaitForChild("Remotes")
local StartRepair = Remotes:WaitForChild("StartRepair")
local StopRepair  = Remotes:WaitForChild("StopRepair")
local QTEResult   = Remotes:WaitForChild("QTEResult")
local GenProgress = Remotes:WaitForChild("GenProgress")
local QTEPrompt   = Remotes:WaitForChild("QTEPrompt")
local Config      = require(GenFolder:WaitForChild("GenConfig"))

-- state per generator:
-- state = { model, progress, running, lastTick, completed, workers = { [player] = {player, failLockUntil, nextQTEAt, qteActive, qteId, qteStart, qteDuration, zoneCenter} } }
local GenStates = {}

local function toolMult(player)
	local char = player.Character
	if not char then return 1.0 end
	for _, t in ipairs(char:GetChildren()) do
		if t:IsA("Tool") and t.Name == "Wrench" then
			return Config.WrenchMultiplier
		end
	end
	return 1.0
end

local function ensureState(model)
	local s = GenStates[model]
	if s then return s end
	s = {
		model     = model,
		progress  = model:GetAttribute("Progress") or 0,
		running   = false,
		lastTick  = time(),
		completed = false,
		workers   = {},
	}
	GenStates[model] = s
	model:SetAttribute("Progress", s.progress)
	return s
end

local function pushProgress(state)
	for plr in pairs(state.workers) do
		GenProgress:FireClient(plr, state.model, state.progress, Config.MaxProgress)
	end
end

local function scheduleNextQTE(w)
	w.nextQTEAt = time() + math.random() * (Config.QTE_IntervalMax - Config.QTE_IntervalMin) + Config.QTE_IntervalMin
end

local function startLoop(state)
	if state.running then return end
	state.running = true
	task.spawn(function()
		while state.running do
			local now = time()
			local dt  = now - (state.lastTick or now)
			state.lastTick = now

			-- stop if no workers
			local count = 0 for _ in pairs(state.workers) do count += 1 end
			if count == 0 then
				state.running = false
				break
			end

			-- accumulate progress
			if not state.completed then
				local total = 0
				for plr, w in pairs(state.workers) do
					local mult = toolMult(plr)
					if w.failLockUntil and now < w.failLockUntil then mult = 0 end
					total += mult
				end
				if total > 0 then
					local perSec = Config.BaseRatePerPlayer * total
					state.progress = math.clamp(state.progress + perSec * dt, 0, Config.MaxProgress)
					state.model:SetAttribute("Progress", state.progress)
					pushProgress(state)
					if state.progress >= Config.MaxProgress then
						state.completed = true
						state.model:SetAttribute("Repaired", true)
					end
				end
			end

			-- QTE lifecycle (no overlap)
			for _, w in pairs(state.workers) do
				if w.qteActive then
					local deadline = (w.qteStart or now) + (w.qteDuration or 0) + Config.QTE_ServerGrace
					if now >= deadline then
						-- timeout -> fail
						if not state.completed then
							state.progress = math.clamp(state.progress - Config.FailPenalty, 0, Config.MaxProgress)
							state.model:SetAttribute("Progress", state.progress)
							pushProgress(state)
						end
						w.failLockUntil = now + Config.FailLockout
						w.qteActive = false
						scheduleNextQTE(w)
					end
				else
					if not w.nextQTEAt then
						w.nextQTEAt = now + 1.0 -- first prompt quickly after starting
					elseif now >= w.nextQTEAt and not state.completed then
						w.qteId       = (w.qteId or 0) + 1
						w.qteStart    = now
						w.qteDuration = Config.QTE_FillSpeed
						w.zoneCenter  = math.random() * (1 - Config.QTE_ZoneWidth) + (Config.QTE_ZoneWidth * 0.5)
						w.qteActive   = true
						QTEPrompt:FireClient(w.player, state.model, {
							id         = w.qteId,
							duration   = w.qteDuration,
							zoneCenter = w.zoneCenter,
							zoneWidth  = Config.QTE_ZoneWidth,
						})
						-- wait for result/timeout before scheduling the next
					end
				end
			end

			task.wait(Config.ServerStep)
		end
	end)
end

StartRepair.OnServerEvent:Connect(function(player, genModel)
	if typeof(genModel) ~= "Instance" or not genModel:IsDescendantOf(workspace) then return end
	local state = ensureState(genModel)

	-- capacity
	local c = 0 for _ in pairs(state.workers) do c += 1 end
	if c >= Config.MaxWorkers then
		GenProgress:FireClient(player, genModel, state.progress, Config.MaxProgress, "full")
		return
	end

	local w = state.workers[player]
	if not w then
		w = { player = player }
		state.workers[player] = w
	end
	w.failLockUntil = nil
	w.qteActive     = false
	w.nextQTEAt     = time() + 1.0

	GenProgress:FireClient(player, genModel, state.progress, Config.MaxProgress)
	startLoop(state)
end)

StopRepair.OnServerEvent:Connect(function(player, genModel)
	local state = GenStates[genModel]
	if not state then return end
	state.workers[player] = nil
end)

QTEResult.OnServerEvent:Connect(function(player, genModel, payload)
	local state = GenStates[genModel]
	if not state then return end
	local w = state.workers[player]
	if not w or type(payload) ~= "table" then return end
	if not w.qteActive or payload.id ~= w.qteId then return end

	local now = time()
	local grace = Config.QTE_ServerGrace
	if not w.qteStart or not w.qteDuration or (now - w.qteStart) > (w.qteDuration + grace) then
		-- expired; ignore and reschedule
		w.qteActive = false
		scheduleNextQTE(w)
		return
	end

	if not state.completed then
		if payload.success then
			state.progress = math.clamp(state.progress + Config.QTE_SuccessBonus, 0, Config.MaxProgress)
		else
			state.progress = math.clamp(state.progress - Config.FailPenalty, 0, Config.MaxProgress)
			w.failLockUntil = now + Config.FailLockout
		end
		state.model:SetAttribute("Progress", state.progress)
		pushProgress(state)
	end

	w.qteActive = false
	scheduleNextQTE(w)
end)

Players.PlayerRemoving:Connect(function(plr)
	for _, state in pairs(GenStates) do
		state.workers[plr] = nil
	end
end)
