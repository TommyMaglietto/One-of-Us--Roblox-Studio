
-- RandomSpawns.server.lua
-- Server-only script. Teleports newly spawned characters to random, safe, non-overlapping spawn Parts.
-- Supports team folders inside workspace.Spawns and a Default folder fallback.

local Players = game:GetService("Players")

-- Change this if you used a different name or location
local SPAWN_FOLDER: Folder = workspace:WaitForChild("Spawns")

-- Use Roblox's better Random object rather than math.random
local rng = Random.new(os.clock())

-- Tracks which spawn is occupied by which user id
local occupied: {[BasePart]: number} = {}

-- Tracks the spawn chosen for a player for their current life, released on death
local reservedForLife: {[Player]: BasePart} = {}

-- Utility: shallow copy and Fisherâ€“Yates shuffle
local function shuffled(list: {any})
	local copy = table.create(#list)
	for i = 1, #list do
		copy[i] = list[i]
	end
	for i = #copy, 2, -1 do
		local j = rng:NextInteger(1, i)
		copy[i], copy[j] = copy[j], copy[i]
	end
	return copy
end

-- Collect all Parts that can act as spawns for this player
local function getSpawnPartsForPlayer(plr: Player): {BasePart}
	-- Team based structure: Spawns/Red, Spawns/Blue, Spawns/Default
	local root = SPAWN_FOLDER
	local folder: Instance? = nil

	if plr.Team ~= nil then
		folder = root:FindFirstChild(plr.Team.Name)
	end

	-- Fallbacks
	if not folder then
		folder = root:FindFirstChild("Default")
	end
	if not folder then
		folder = root
	end

	-- Collect BaseParts with Enabled not false
	local parts = {}
	for _, inst in ipairs(folder:GetDescendants()) do
		if inst:IsA("BasePart") then
			-- If there is no Enabled attribute, treat it as enabled
			local enabledAttr = inst:GetAttribute("Enabled")
			if enabledAttr == nil or enabledAttr == true then
				table.insert(parts, inst)
			end
		end
	end

	-- Also allow spawn Parts placed directly under the folder if you used child Parts not Descendants
	for _, inst in ipairs(folder:GetChildren()) do
		if inst:IsA("BasePart") then
			local enabledAttr = inst:GetAttribute("Enabled")
			if enabledAttr == nil or enabledAttr == true then
				table.insert(parts, inst)
			end
		end
	end

	return parts
end

-- Check whether the space above a spawn is free and the spawn is not currently occupied
local function isSpawnFree(spawnPart: BasePart, ignoreModel: Model?): boolean
	-- Quick check for reservation
	if occupied[spawnPart] ~= nil then
		return false
	end

	-- Volume check above the pad so we do not spawn inside walls or props
	-- Sample a box that fits a standing R15
	local height = 6
	local half = Vector3.new(spawnPart.Size.X * 0.45, height * 0.5, spawnPart.Size.Z * 0.45)
	local center = spawnPart.CFrame * CFrame.new(0, half.Y + 2, 0) -- a bit above the pad

	local params = OverlapParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	if ignoreModel then
		params.FilterDescendantsInstances = { ignoreModel }
	end

	local touching = workspace:GetPartBoundsInBox(center, half * 2, params)
	for _, p in ipairs(touching) do
		if p.CanCollide and p.Transparency < 1 then
			return false
		end
	end
	return true
end

-- Place the character at a given spawn, keeping the Part's facing
local function placeCharacterAt(character: Model, spawnPart: BasePart)
	local offsetY = 3
	local cf = spawnPart.CFrame * CFrame.new(0, offsetY, 0)

	-- Use modern, reliable placement
	character:PivotTo(cf)
end

-- Pick an available spawn. Prefer free, fall back to any if all are busy
local function pickSpawnFor(plr: Player, character: Model): BasePart?
	local candidates = getSpawnPartsForPlayer(plr)
	if #candidates == 0 then
		warn("No spawn parts found for player " .. plr.Name .. ". Create Parts in workspace.Spawns.")
		return nil
	end

	for _, part in ipairs(shuffled(candidates)) do
		if isSpawnFree(part, character) then
			return part
		end
	end

	-- Fallback if everything looks occupied or blocked
	return candidates[rng:NextInteger(1, #candidates)]
end

-- Reserve a spawn and release it on death or character removal
local function reserveAndPlace(plr: Player, character: Model)
	-- Wait for critical parts before moving the character
	local hrp = character:WaitForChild("HumanoidRootPart", 10)
	local hum = character:WaitForChild("Humanoid", 10)
	if not hrp or not hum then
		warn("Character missing HRP or Humanoid for " .. plr.Name)
		return
	end

	local spawnPart = pickSpawnFor(plr, character)
	if not spawnPart then
		return
	end

	-- Mark as occupied by this user id and remember for this life
	occupied[spawnPart] = plr.UserId
	reservedForLife[plr] = spawnPart

	-- Place the character
	placeCharacterAt(character, spawnPart)

	-- Optional short spawn protection
	-- Comment out if you do not want protection
	local ff = Instance.new("ForceField")
	ff.Visible = false
	ff.Parent = character
	task.delay(2, function()
		if ff and ff.Parent then
			ff:Destroy()
		end
	end)

	-- When the player dies, free up the spawn
	hum.Died:Once(function()
		local saved = reservedForLife[plr]
		if saved and occupied[saved] == plr.UserId then
			occupied[saved] = nil
		end
		reservedForLife[plr] = nil
	end)

	-- Also free the spot if the character is removed without Died firing
	character.AncestryChanged:Connect(function(_, parent)
		if parent == nil then
			local saved = reservedForLife[plr]
			if saved and occupied[saved] == plr.UserId then
				occupied[saved] = nil
			end
			reservedForLife[plr] = nil
		end
	end)
end

-- Hook player spawns
local function onCharacterAdded(plr: Player, character: Model)
	-- Defer slightly so physics settles, then place
	task.defer(function()
		reserveAndPlace(plr, character)
	end)
end

local function onPlayerAdded(plr: Player)
	plr.CharacterAdded:Connect(function(char)
		onCharacterAdded(plr, char)
	end)

	-- If their character already exists, place it
	if plr.Character then
		onCharacterAdded(plr, plr.Character)
	end
end

-- Connect existing players and future players
for _, plr in ipairs(Players:GetPlayers()) do
	onPlayerAdded(plr)
end
Players.PlayerAdded:Connect(onPlayerAdded)
